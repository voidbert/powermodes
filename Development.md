# powermodes development

## Installation

See [README.md](README.md).

## Toolchain

### Documentation

Project documentation can be generated by running:

```bash
$ doxygen
```

If you plan to contribute any code, make sure to document it thoroughly. Check out doxygen's
documentation [here](https://www.doxygen.nl/manual/index.html).

### Static code analysis

This project uses [pylint](https://pypi.org/project/pylint/) and [mypy](https://mypy-lang.org/) to
assure code quality. These tools can be installed with the following command:

```bash
$ pip install pylint mypy
```

Before opening a pull request, make sure that running the following commands from the root of the
repository doesn't result in any errors:

```bash
$ pylint powermodes
$ mypy --strict powermodes
```

## Error system

Before hacking some patches into powermodes or developing your own plugin, it's crucial to
understand how the error system works. A custom error system was developed so that, unlike with
exceptions, a method can report many different errors, or even report warnings without having to
be exited.

### Creating errors

The error system is implemented in the [error.py](powermodes/error.py) file. Here's how you create
an error:

```python
from .error import Error, ErrorType # Use ..error if this is plugin code

error   = Error(ErrorType.ERROR,   'sample error')
warning = Error(ErrorType.WARNING, 'sample warning', 'plugin_name')
```

As seen with `warning`, the origin of the error can be specified (`None` for powermodes itself, or
the name of the plugin it was reported from). This way, when it's printed out, it's easy to see who
caused the error. However, **you shouldn't need to specify your error's origin**, as that will be
be set automatically.

Printed errors:
```
>>> from .error import print_error

>>> print_error(error)
error: sample error

>>> print_error(warning)
plugin_name warning: sample warning
```

### Raising errors

A function that raises errors can have one of the two following type signatures:

- `def fn(...) -> tuple[Union[Any, None], Union[Error, None]]`
- `def fn(...) -> tuple[Union[Any, None], list[Error]]`

Along with the return value, they may return a possible error or a list of errors. Here's an
example.

```python
def read_text_file(path: str) -> tuple[Union[str, None], Union[Error, None]]:
    try:
        with open(path) as f:
	      return (f.read(), None)
    except OSError:
        return (None, Error(ErrorType.ERROR, f'failed to read text file "{path}"'))
```

### Handling errors

Error handling is done with two functions from the module `error`: `handle_error` and
`handle_error_append`. The former should only be used in `main`, as it prints the errors to the
user and may exit the program, if the return value of the function you give it is `None`, and
non-warning errors were reported. `handle_error_append` is the method you likely should be using.

```python
def error_handling_example() -> tuple[None, list[Error]]:
    errors = []
    handle_error_append(errors, i_may_fail(42))
    handle_error_append(errors, i_may_fail(0xbeef))
    return (None, errors)
```

### Resiliency

powermodes tries to move on, even when errors happen. Here are a few guidelines:

- Don't let "normal" exceptions happen. It's unnecessary to handle out of memory errors, but make
  sure errors that may happen, especially coming from the user, are handled. If an exception
  happens, it's game over for powermodes.

- Try to fix things. Is your plugin wrongly configured? Warn the user, then either fix it or ignore
   it, but do not crash powermodes.

## Writing plugins

A plugin is just a Python module in the `powermodes/plugins` directory. The module name must be a
valid Python identifier. Use Python's
[`str.isidentifier`](https://docs.python.org/3/library/stdtypes.html#str.isidentifier) to test if
your module name is valid. Modules whose names start with `__` (two underscores) are ignored.

Plugins must specify two constant strings: `NAME` and `VERSION`. Also, two methods need to be
specified:

```python
NAME = 'example'
VERSION = '0.1'

def validate(config: dict[str, Any]) -> tuple[list[str], list[Error]]:
    ...

def configure(config: Any) -> tuple[Bool, list[Error]]:
    ...
```

### Configuration validation

`validate` will be called before `configure`. It's job is to validate a configuration file. The
object it receives is the full configuration file, filtered not to include data from other plugins,
and deep-copied so that there are no consequences from accidental modifications on your part.

```toml
[powersave]
    example = "Hello, world"
    other_plugin = [ 123, 321 ]

[performance]
    example = "Hello, Jupiter"
    other_plugin = [ ]
```

Only the following configuration is given to example's `validate`:

```toml
[powersave]
    example = "Hello, world"

[performance]
    example = "Hello, Jupiter"
```

As a Python dictionary, the `config` is:
```python
{ 'powersave': { 'example': 'Hello, world'}, 'performance': { 'example': 'Hello, Jupiter' } }
```

`validate` must return the powermodes for which the configuration is valid (along with errors /
warnings). Suppose `example` only likes to salute gas giants; it must return something like

```python
([ 'performance' ], Error(ErrorType.ERROR, f'world is not a gas giant'))
```

The `example` object in the `powersave` powermode will be removed, so that you don't have to
handle it if the user chooses to apply that powermode.

#### Why this design?

Why not call `validate` many times, once per powermode? That isn't done because, this way, your
plugin can check if all powermodes include a configuration object for it. That way, if you are
handling some operating system state, like CPU frequency, for example, you can warn the user that
they may end up with a partially configured system if they switch from a mode to another.

### Configuration application

`configure`'s interface is simpler than `validate`'s. Consider the previous example. If the user
chooses the `performance` mode, configure is called with the `"Hello, Jupiter"` argument, and must
return whether it was successful, along with a list of errors / warnings that may have happened,
for example, `(True, [])`.
